---
title: 奇安信攻防社区-CVE-2024-22259(CVE-2024-22243 绕过) 浅析
url: https://forum.butian.net/share/2810
clipped_at: 2024-03-26 23:07:56
category: default
tags: 
 - forum.butian.net
---


# 奇安信攻防社区-CVE-2024-22259(CVE-2024-22243 绕过) 浅析

# 0x01 前言

Spring 官方近期披露了 CVE-2024-22243，在受影响版本中，由于 UriComponentsBuilder 处理 URL 时未正确处理用户信息中的方括号 `[` ，攻击者可构造包含方括号的恶意 URL 绕过主机名验证。如果应用程序依赖 UriComponentsBuilder.fromUriString() 等方法对 URL 进行解析和校验，则可能导致验证绕过，出现开放重定向或 SSRF 漏洞。由于修复不完善，导致了绕过。所以 Spring 官方披露了 CVE-2024-22259 进行了补充。

# 0x01 CVE-2024-22259

## 1.1 漏洞描述

在受影响版本中，UriComponentsBuilder 是 Spring Web 中用于构建和操作 URI 的工具类。由于对 CVE-2024-22243 的修复不充分，攻击者可构造一下两类 url 绕过主机名验证，导致开放重定向或 SSRF 漏洞。

![image.png](assets/1711465676-6cd35fcb99a012ee03b808355eb8f78c.png)

## 1.2 影响版本

Spring Framework

-   6.1.0 - 6.1.3
-   6.0.0 - 6.0.16
-   5.3.0 - 5.3.31
-   Older, unsupported versions are also affected

## 1.3 漏洞分析及复现

问题主要还是在 URI 的工具类 UriComponentsBuilder 中，对 CVE-2024-22243 的修复不充分进行了补充。CVE-2024-22243 的具体分析可以参考[https://forum.butian.net/share/2781。](https://forum.butian.net/share/2781%E3%80%82)

在具体漏洞版本中，以org.springframework.web.util.UriComponentsBuilder#fromUriString方法为例，实际上整个逻辑比较简单，主要是通过正则匹配URI中各个部分的内容，然后完成对应的封装：

![image.png](assets/1711465676-ebe8ddb68d9c7248e5f6b471bb34f65c.png)

同时若未匹配相关信息，会抛出`throw new IllegalArgumentException("[" + uri + "] is not a valid URI");`异常，否则进行进一步的封装，同时这里对 scheme 和 host 进行了一定的合法性检查：

![image.png](assets/1711465676-4ae7949c7d3af6d303c78157ce0bf416.png)

下面通过相关的 commit 记录[https://github.com/spring-projects/spring-framework/commit/1d2b55e670bcdaa19086f6af9a5cec31dd0390f0](https://github.com/spring-projects/spring-framework/commit/1d2b55e670bcdaa19086f6af9a5cec31dd0390f0) 查看具体的修复方式：

首先对正则进行了调整，移除了 USERINFO 中对`@`以及 IPV4 格式的 host 对方括号 `[`的匹配：

![image.png](assets/1711465676-685dbc9252599ef003003c32515ee29f.png)

对@的匹配形式进行了调整：

![image.png](assets/1711465676-d811017666f382ac61dfc8830bb3e746.png)

其次对原有 scheme 和 host 的合法性检查进行了调整，原本是检查 scheme 必须以 http 开头且 host 不允许为 null，修复版本统一封装到 checkSchemeHost 方法进行检查了：

![image.png](assets/1711465676-7a9fa37387c3284f4bf04886b7e0a15e.png)

checkSchemeHost 方法实现如下，在原有基础上，若请求 url 中的 host 以 `[`开头但不以 `]` 结尾的话会抛出异常：

![image.png](assets/1711465676-71bdffde6dd8397c7cfa2e64dec9943d.png)

三梦师傅也公开了对应的 poc：

```Java
UriComponents uri =UriComponentsBuilder.fromHttpUrl("http://@forum.butian.net[@risk.com").build();
```

可以看到跟 CVE-2024-22243 情况类似，解析完成后 USERINFO 为 null，对应的 host 并不是预期的 risk.com，而是 forum.butian.net：

![image.png](assets/1711465676-6ff2d8683d735336dff1d391c4860979.png)

在某些场景下可能会通过返回的 UriComponents 可以轻松的获取 URI 中类似协议、端口、host 等各部分内容。例如可以通过 getHost 方法获取当前请求的 host，结合实际的业务场景检查在不在可允许的域名范围或者 ip 内，来避免类似 SSRF/Open Redirect 等安全风险。

若发起请求的 http 组件能解析上述的 URL，且获取到的 host 存在解析差异的话，会由于解析差异导致绕过安全检查的风险。

# 0x02 实际缺陷场景

实际的缺陷还是集中在类似的安全检查中，结合 host 解析差异导致了绕过的风险。下面看一些实际的缺陷场景。

## 2.1 URL Redirect

Java 中最常见的重定向方式就是通过 HttpServletResponse 跳转。其会向浏览器发送一个特殊的 Header，然后由浏览器来做重定向，转到指定的页面：

```Java
@GetMapping("/redirectUrl")
public void redirect(String url, HttpServletResponse response) throws IOException {
    URL test = new URL(url);
    response.sendRedirect(url);
}
```

上述 poc 浏览器在解析跳转时会直接重定向到 risk.com 去。此时若通过 UriComponentsBuilder 工具类获取请求的 host 进行安全检查时，会存在被绕过的风险。

此外，在三梦师傅提供的 demo 里，通过 Spring 的 redirect 视图同样也存在类似的场景：

![image.png](assets/1711465676-ab45c77035ae48580956d7815b01556c.png)

以 SpringBoot 中的 ThymeleafViewResolver 为例，查看具体的实现方式。

首先调用 createView 方法，创建视图，并且判断传入的视图名是否是以"redirect:"开头，然后通过截取字符串获取重定向的 url：

![image.png](assets/1711465676-699c9309d3046ee7193d07cd6c5b96f0.png)

然后创建 RedirectView 对象，会调用 renderMergedOutputModel() 方法对视图进行渲染，并调用 sendRedirect() 方法：

![image.png](assets/1711465676-995270fb2656e9797be0e4327f65d721.png)

在 sendRedirect() 方法，实现转发的方式是通过 HttpServletResponse 跳转：

![image.png](assets/1711465676-8f42aeb0a56556071c091211fef49f58.png)

## 2.2 SSRF

相比 URL Redirect，SSRF 会更苛刻一些。在绕过了结合 UriComponentsBuilder 工具类实现的安全检查后，还必须考虑对应的 url 是否能被对应的 http 组件成功解析，达到利用的目的。

类似 httpclient4 在请求上述的 poc 时，会抛出 IllegalArgumentException 异常，无法正常请求：

![image.png](assets/1711465676-cb374d5fe26bb5cc5f85d5fd20fd2a7c.png)

本质上是因为其会通过 org.apache.http.client.utils.URIBuilder 解析 url 来获取 host，是在基于 java.net.URL 上进行处理的。

httpclient3 在解析时则会抛出 Invalid uri 异常导致无法正常请求：

![image.png](assets/1711465676-b48ef8dbda20e1eef5b47289b9b7c4ec.png)

对一些常见的 http 请求组件进行了枚举，发现其中 okhttp3 可以成功解析上述 poc 并成功请求 risk.com:

![image.png](assets/1711465676-415f1eabd1fa9cfb6431bdabbffa148a.png)

```Java
Request request = new Request.Builder()
        .url("http://@forum.butian.net[@risk.com")
        .build();
```

![image.png](assets/1711465676-f14f604c26987eddeda519ef6e3c679c.png)

具体 okhttp 的解析过程可以参考[https://forum.butian.net/share/2427](https://forum.butian.net/share/2427)

# 0x03 拓展

## 3.1 JerseyUriBuilder

Jersey 是 JAX-RS API 的一种具体实现，它提供了一套完整的、易于使用的 RESTful Web 服务框架，可以帮助 Java 开发人员更快速、更方便地构建 RESTful Web 服务。同样的也有着类似 UriComponentsBuilder 的工具类。

在 Jersey 的请求解析过程中：

![image.png](assets/1711465676-096c3bb475f1fac45d1c54157e855863.png)

首先从 HttpServletRequest 对象中获取到请求 URL、Servlet 路径和请求 URI 等信息，然后调用`UriBuilder.fromUri()`方法，从给定的字符串中解析出 URI，并返回一个对应的 UriBuilder 实例。如果输入的 URL 字符串不符合 URI 格式，就会抛出 IllegalArgumentException 异常：

![image.png](assets/1711465676-b668e805676f71be1b7c81160c4bb876.png)

跟 Spring 的 UriComponentsBuilder 类似，javax.ws.rs.core.UriBuilder 同样也提供了一种简单而强大的方式来构建和处理 URI，避免了手动拼接字符串的繁琐和容易出错的问题。通过添加路径、查询参数、片段等组件来构建完整的 URI:

```Java
UriBuilder absoluteUriBuilder = UriBuilder.fromUri(url);
URI uri = absoluteUriBuilder.build();
```

当然也可以直接使用 org.glassfish.jersey.uri.internal.JerseyUriBuilder 来构建完整的 URI，解析过程是类似的：

![image.png](assets/1711465676-e5fc1fe14d340630e4bdb0636764dcbf.png)

```Java
UriBuilder absoluteUriBuilder = JerseyUriBuilder.fromUri(url);
URI uri = absoluteUriBuilder.build();
```

下面简单看看具体的解析过程：

![image.png](assets/1711465676-1d3b0dcd128da091735e11c80df691ac.png)

具体的解析是通过org.glassfish.jersey.uri.internal.UriParser#parse方法进行处理的：

![image.png](assets/1711465676-4e4f100c66c715dfc0681602a63c10e7.png)

在解析过程中，会遍历对应 URL 的字符，并通过对应的分隔符 delimiters 调用 parseComponent 方法获取对应的模块的内容：

![image.png](assets/1711465676-842b262bc09d304296ca336ff73958db.png)

解析 Authority 内容同理，可以看到 host 的内容为经过一系列分隔符处理后的 comp 的值：

![image.png](assets/1711465676-bcd1641d9468d14e25e2bca0900b5635.png)

在请求上述 poc 时，最后获取的 host 内容如下：

![image.png](assets/1711465676-8e821a816d6ce613958ebd38cee7e92b.png)

解析完成后，会通过 build 方法将解析结果转换成 java.net.URI 对象，即可获取对应的属性了。

正常情况下，将解析后的结果`http://@forum.butian.net``[``@risk.com`实例化成 URI 对象因为包含不合理的字符抛出 java.net.URISyntaxException 异常：

![image.png](assets/1711465676-bd06ddb3d7937771fe02f452ffed9eef.png)

但是 UriBuilder 在实际处理时会有自己的逻辑，具体实现在 org.glassfish.jersey.uri.internal.JerseyUriBuilder#\_build 方法：

![image.png](assets/1711465676-10cef252709a97ed79d36cdbcaa55066.png)

如果对应的values不为空，会直接实例化java.net.URI对象，否则调用org.glassfish.jersey.uri.UriTemplate#createURI进行进一步处理,处理后继续调用createURI方法实例化java.net.URI对象，此时会抛出java.net.URISyntaxException异常：

![image.png](assets/1711465676-92ed834c0f7fb3cf0a0f1ea3c6baa540.png)

jersey 对异常进行了捕获处理，此时会设置 host 为 null，也就是说 类似上述的 CVE-2024-22259/CVE-2024-22243 的 poc 最后获取到的 host 均为 null：

![image.png](assets/1711465676-91308be66b63eba65e58ddae980b11a4.png)

虽然 Jersey 工具类在解析上述 poc 时获取到的 host 为 null，在存在解析差异的前提下，若处理不当仍可能会存在潜在的绕过风险。下面是一个实际的安全检查例子：

首先看一个具体代码防护逻辑：

```Java
if (StringUtil.isNotBlank(host)) {
    //非法参数：url不在可允许的域名范围或者ip内
    return !checkHost(host);
} else {
    return true;
}
```

NullPointerException 异常是 Java 中的一种运行时异常，它通常在程序中出现空指针引用时抛出。当尝试对一个为 null 的对象进行方法调用、属性访问或者数组操作时，就会触发 NullPointerException 异常。

为了避免在 host 检查时不必要的 NullPointerException 异常问题，在检查时先进行了判空操作，然后再校验请求 host 是否合法。这里如果获取到的 host 为 null 的话，也会返回 host 合法。

因为在实际请求过程中，大很多时候会认为**实际上请求一个 null 的 host 并不能成功，会根据对应的异常捕获机制进行处理**。所以逻辑上应该没有什么问题。实际上结合前面的分析 okhttp3 却能完成对应的请求。在实际的代码审计过程中需要额外注意。

## 3.2 其他

结合上面的案例，在实际业务场景中，如何安全的获取请求的 host 对开放重定向或 SSRF 漏洞进行防御是一个很值得思考的问题。主要需要解决解析差异的问题。下面列举一些实际的方法。

例如在进行 SSRF 漏洞防护时，可以结合对应的 http 请求组件进行 AsyncDns 的处理。例如 okhttp 提供了类似的接口[https://square.github.io/okhttp/4.x/okhttp/okhttp3/-dns/lookup/](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-dns/lookup/) ，因为都是同一个组件内的解析，避免了解析差异导致的绕过问题：

![image.png](assets/1711465676-dfa15446890e889846a11e2675678674.png)

此外，有时候可能需要一个通用的工具类进行获取，前面也分析过 Java 中比较常见获取 host 的场景，通过`URI uri = new URI(url);`进行获取，结合其对应的非法字符检查，安全性会更高一些。

但是在实际编写检测逻辑时还是需要考虑具体的业务场景，以 URL Redirect 为例，存在风险的代码可能存在如下几种情况：

-   直接获取整个 url 链接进行请求，比如 response.sendRedirect(url)
-   预定义好了协议，拼接了域名，比如 response.sendRedirect("http://"+url)
-   预定义好了协议和域名，但是存在使用@或者。绕过的问题，比如 response.sendRedirect("[https://xxx.xxx.com"+url](https://xxx.xxx.com/))

那么在获取 host 时就要结合实际的场景进行考虑，避免类似前面返回 null 的 host 导致检查失效的问题：

```Java
URI uri = new URI(url);
return uri.getHost().toLowerCase();
```